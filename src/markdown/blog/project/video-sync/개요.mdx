---
title: 비디오 싱크 플레이어 만들기(1)
subtitle: 개발에 앞서 전반적인 구조 고민
tags:
  - 설계
  - 개요
  - 비디오 싱크 플레이어
date: 2025-03-23T00:00:00+09:00
---

## 개요
이따금씩 집 근처 마트 2층의 전자제품 코너를 마트에 놀러가곤 한다. 전자기기 신제품들을 가볍게 둘러보는 재미가 쏠쏠하기 때문이다. 특히 애플 제품과 삼성 제품을 모두 볼 수 있기에 양사 신제품이 나오면 빠지지 않고 방문한다. 여느때처럼 둘러보고 있었는데, 애플 제품 진열대에서 평소 신경쓰지 못했던 것이 눈에 띄었다. Mac 컴퓨터의 화면 보호기 영상이 약속이라도 한듯이 싱크과 일치되어 재생되는 광경이 눈에 들어왔다

<video autoPlay loop muted playsInline width="768">
  <source src="/markdown/blog/project/video-sync/apple_sync.mp4" type="video/mp4" />
</video>

이후 삼성 코너에 갔는데, 기대와 다르게 화면 보호기 영상의 싱크가 잘 맞지 않았다. 평소라면 의식하지 않았겠지만, 이미 칼군무처럼 딱딱 맞아떨어지는 광경을 보아서 그런지 미묘하게 싱크가 맞지 않는 영상에서 약간의 불편함을 느꼈다

<video autoPlay loop muted playsInline width="768">
  <source src="/markdown/blog/project/video-sync/samsung_sync.mp4" type="video/mp4" />
</video>

다시 애플 코너로 돌아와 싱크가 맞아 떨어지는 영상들을 보며 잠시 감상에 빠져들었다. 그러면서 문득 궁금해졌다

> 어째서 서로 다른 컴퓨터의 영상이 약속이라도 한 듯이 싱크를 맞춰서 재생할 수 있는 것일까, 도대체 무슨 원리로 저렇게 동작하는 것일까??

동시에 도전 의식이 생겼다. 나도 애플처럼 영상들의 싱크를 맞추는 애플리케이션을 웹으로 만들고 싶어졌다

---

## 기술적 고민들
이후 구현을 위한 기술적인 고민들을 하였다. 사실 처음엔 단순한 로직으로 금방 구현이 될 것이라 생각하였다. "영상 재생시점을 공유하여 그 시점에 일치하게끔 프레임 위치를 조정하기만 하면 끝"이라 쉽게 생각하였다. 틀린 생각은 아니지만, '일치'라는 단어가 주는 엄밀함을 충분히 고려하지 않았던 것 같다. 결국 이것이 단순한 문제가 아님을 조금 더 고민해본 다음에야 깨달을 수 있었다

### 어려움 1) 네트워크 딜레이
Sub 브라우저가 Main 브라우저 영상의 싱크를 따라가려는 상황을 가정해보자. 이를 위해선 다음과 같이 Main 브라우저에게 현재 재생중인 프레임 정보를 질의해야만 한다:

![시퀀스 다이어그램](/markdown/blog/project/video-sync/sequence_diagram.png)

문제는 Sub 브라우저가 프레임에 대한 정보를 수신하더라도, 네트워크 딜레이로 인해 오차가 발생하게 된다. Sub 브라우저 입장에선 요청 후 응답이 오기까지의 네트워크 딜레이를 측정할 수는 있지만, 실제 재생 시점을 알아낸 이후 응답이 오기까지의 딜레이는 정확하게 측정할 수 없다

딜레이 계산을 위해 Main 브라우저가 `Date.now()`를 사용하여 `t1`을 `Response`에 담아주더라도 main과 sub는 물리적으로 분리된 시스템이기 때문에 `Date.now()` 만으로는 정밀도를 보장할 수 없다(운이 나쁘면 `t2`가 `t1`보다 앞설 수도 있다). 결국 `t1`, `t2` 값을 보장하기 위해선 **두 브라우저간 시계 동기화가 선행되어야만 한다**

### 어려움 2) 프레임 레이트
동영상의 프레임 레이트는 꽤나 다양하다. 일반적으론 30fps이지만, 낮게는 24fps(영화)에서 높게는 120fps(슬로우 모션 영상)까지 된다. 문제는 프레임 레이트에 따라 "추정 프레임"의 오차 정도가 심해질 수 있다는 것이다. 결론부터 말하자면 **프레임 레이트가 낮을수록 오차 민감도가 높아진다**

앞서 언급한 네트워크 딜레이를 정밀하게 측정하여 Main 브라우저의 재생 시점 프레임(=추정 프레임)을 알아내더라도, 추정치 이기 때문에 오차는 필연적이다. 만일 프레임 레이트가 높다면 오차 민감도가 낮아지기 때문에 오차 보정 작업을 수행하지 않아도 된다(반대로 프레임 레이트가 낮다면 보정 작업을 수행해야만 한다)

예를들어, 100fps의 동영상 싱크를 맞추어야 한다고 하자(시계는 동기화 된 것으로 가정):
- Main 브라우저가 응답한 시점(`t1`): 36ms
- Main 브라우저가 응답한 `Response` 객체:
  ```json
  {
    "frameNumber": 3537
  }
  ```
- Sub 브라우저가 Response 객체를 수신한 시점(`t2`): 1,609ms

위의 정보를 통해 Sub 브라우저는 Main 브라우저의 재생시점 프레임을 다음과 같이 추정한다:
- 네트워크 딜레이(`t2 - t1`): 1,573ms(=1,609ms - 36ms)
- 100fps 영상이므로 1 프레임당 재생시간은 10ms -> **157.3개(=1,573ms / 10ms)의 프레임을 더해주어야 함**
- 추정 프레임: 3694.3(=3537 + 157.3)

프레임은 이산적이기 때문에 소수점 없이 3694 또는 3695로 결정해 주어야 한다(오차를 적게 하려면 3694가 적절해보인다). 3694로 추정하면 0.3 프레임의 오차가 발생하고, 이로인해 3ms의 오차 또한 발생한다. 하지만 3ms의 오차는 인간의 눈으로 구분이 불가능한 수준이기 때문에 보정할 필요가 없다

문제는 100fps처럼 높은 프레임 레이트의 영상이 아닐 때이다. 위와 동일한 가정하에 프레임 레이트만 100fps -> 1fps로 변경해보자

Sub 브라우저는 Main 브라우저의 "추정 프레임"을 다음과 같이 계산한다:
- 네트워크 딜레이(`t2 - t1`): 1,573ms
- 1fps 영상이므로 1 프레임당 duration은 1,000ms -> **1.573개(=1,573ms / 1,000ms)의 프레임을 더해주어야 함**
- 추정 프레임: 3538.573(=3537 + 1.573)

마찬가지로 프레임은 이산적이기 때문에 3538 또는 3539로 결정해 주어야 한다. 3539로 추정하면 0.427 프레임의 오차가 발생하고, 이로인해 427ms의 오차 또한 발생한다. **이는 충분히 눈으로 구분할 수 있는 수준이다!**

물론 1fps는 극단적인 예시이기 때문에 실용성은 없어보인다. 동영상이라 부를 수 있는 최소 프레임 레이트인 16fps에서 따져봐야한다. 16fps 영상의 오차의 최대치는 31.25ms이다(오차의 최대치는 `500ms / 프레임레이트`로 계산 가능). 이 수치가 인간이 구분 가능한지는 더 알아봐야겠지만, 네트워크 딜레이가 정확하게 계산되지 않을 수 있다는 점, 다른 변수에 의한 오차(ex. 브라우저의 JS 스크립트 실행으로 인한 딜레이 등)를 고려하면 31.25ms의 오차는 큰 영향을 미칠 수 있다

어찌되었건 이 **오차를 잡아줄수록 시스템의 안정성은 올라간다**. 오차 보정 작업은 충분히 고려할만하다

---

## 네트워크 토폴로지
이후 애플리케이션이 구동되는 네트워크 토폴로지를 고민하였다

### 클라이언트/서버 토폴로지

가장 먼저 떠오른 것은 클라이언트/서버 토폴로지였다. 클라이언트/서버와 마찬가지로 Sub/Main으로 구성하여 하나의 Main을 기준삼아 다수의 Sub가 Main에게 질의-응답하는 방식으로 싱크를 맞추는 구조를 생각하였다:

![클라이언트/서버 토폴로지](/markdown/blog/project/video-sync/client_server_topology.png)

단순하지만 몇 가지 한계점이 짐작되어 기각하였다:
- 예상되는 문제점 1) Main 브라우저에 장애가 발생할 경우 시스템 fail이 발생할 수 있다
- 예상되는 문제점 2) Sub 브라우저의 갯수가 증가할수록 시스템 안정성이 떨어진다:
  - Sub의 갯수가 늘어남에 따라, (프레임 추정을 위한)질의 또한 늘어나므로 Main의 비동기 처리 로직이 많아짐에 따라 블로킹 포인트 또한 많아질 것으로 예상하였다
  - Main이 관리해야 하는 연결이 많아지므로, Main의 네트워크 리소스 부하 증가를 예상하였다(대역폭이 충분치 않다면 시스템 fail이 발생할 수 있음)

이렇듯 특정 브라우저에 과도한 책임이 몰리는 방식은 한계점이 명확하다 생각하여, 책임을 분담하는 방식을 고민하였다

### 링 토폴로지
책임 분담을 위해 Main/Sub 구분없이 모두가 Main인 동시에 Sub가 되는 공평한 형태를 고민하였다. 즉, 시스템 안정을 위해 모든 노드들이 질의-응답의 책임과 의무를 가져가는 구조를 생각하였다:

![링 토폴로지](/markdown/blog/project/video-sync/ring_topology.png)

이제 특정 브라우저 하나가 다운되더라도 전체 시스템이 깨지지 않는다. 또한 브라우저의 갯수가 늘어나더라도 네트워크 리소스 부하가 증가하지 않는다. 시스템 안정성이 더 높아진 구조라 생각하여 채택하였다. 하지만 구현의 복잡도는 더 높아졌다. 노드(브라우저)의 추가(연결), 삭제(연결 해제) 과정이 클라이언트/서버 토폴로지에 비해 더 복잡해졌기 때문이다

클라이언트/서버 토폴로지의 경우 새로운 브라우저 추가시 Main 브라우저와 새로 연결만 하면 된다(삭제 시에는 연결 해제만 하면 된다). 하지만 링 토폴로지의 경우 새로운 브라우저를 추가하려면 기존 연결된 두 개의 브라우저 연결을 각각 끊고 새로운 연결을 각각 생성해주어야 한다. 반대로 삭제되는 브라우저는 단순히 연결만 끊으면 되는 것이 아니라, 자신과 연결된 두 개의 브라우저를 서로 연결시켜준 다음에야 삭제될 수 있다

---

## 남은 과제
전반적인 그림은 잡았지만 아직 명확하진않다. 일단 결정된 링 토폴로지를 기반으로 시스템 아키텍쳐를 설계해야만 한다. 그래야만 애플리케이션 설계를 시작할 수 있다. 또 사용 가능한 API, 패키지도 찾아봐야 한다. 빠르게 찾아봤을 때, 웹에서 저수준으로 영상 데이터를 조작하려면 [WebCodecs API](https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API)를 사용하면 된다고는 하는데, 너무 생소한 API인지라 적절한 API인지 더 조사해봐야 한다

어렵지 않을 것이라 짐작하여 가볍게 시작했는데 생각보다 고려할 것과 할 일들이 많다. 잘 해낼 수 있을지 벌써부터 걱정이 된다