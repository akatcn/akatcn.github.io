---
title: 비디오 싱크 플레이어 만들기(2)
subtitle: 시계 동기화 방식 고민
tags:
  - 설계
  - 시계 동기화
  - 비디오 싱크 플레이어
date: 2025-03-28T00:00:00+09:00
---

## 설계에 앞서 유의할 것들
설계는 어렵다. 세부사항을 전부 고려할 수 없기 때문이다. 결정한 틀 내에서 차근차근 구현하다보면 어느샌가 해결하기 정말 어려운 문제를 맞닥뜨린다. 해결이 된다면야 문제될 것은 없지만, 가끔은 어려운 정도를 넘어서서 불가능에 가까운 문제를 직면하기도 한다(최악의 경우 전부 갈아 엎기도 한다). 그래서 설계를 하는 것은 늘 어렵고 두렵다. 특히나 지금처럼 경험해보지 않은 분야(영상 처리, 시계 동기화 등...)를 다룰 때는 불확실성이 더더욱 커진다

그래서 그동안의 실패를 교훈삼아 다음과 같은 주의를 기울이려 한다:

1. '실현 가능성'을 따져봐야 한다. 기술적으로 불가능함에도 불구하고 가능한 것으로 판단하거나, 내가 다룰 수 없는 수준의 기술임에도 불구하고 의욕에 앞서 쉽게 사용할 수 있다고 오판한 적이 있었다. 그러다 나중에 가서 이것이 생각 이상으로 복잡하고 어려운 기술임을 알게되어 좌절한 순간이 몇 번 있었다. 같은 실수를 반복하지 않기 위해 시스템 설계와 동시에 리서치를 함께 하려고 한다

2. 논리적 모순이 없는지 점검해야 한다. 컴포넌트의 입출력이 얽혀있을 때 입출력 선후관계를 제대로 파악하지 않아, 논리적 모순을 인지하지 못하고 나중에 낭패를 본 적이 있었다. 이런 부분이 존재하는지 꼼꼼히 살펴봐야 한다

3. '이것이 최선인가??'라는 의문을 계속해서 던져봐야 한다. 나중에 가서 더 나은 해결책을 본 뒤, 이미 정해버린 시스템을 깨고 싶지 않아 밀어붙였던 고통의 경험이 있다

4. 예외 상황에 너무 깊게 빠져들지 않아야 한다. 동시 입력, 네트워크 단절, 어뷰징 등 예외적인 상황을 너무 심각하게 고민하다보면 나아가질 못한다. 내가 감당 가능한 수준까지의 예외 상황을 고려하고, 그 이후에 발생하는 것은 그때가서 처리토록 하는게 맞다

---

## 동작 원리 재정의
시스템 전반적인 설계에 앞서 영상의 프레임을 어떻게 동기화 시킬지에 대해 다시금 진지하게 고민하였다. 처음 생각했던 방식은 현재 재생중인 프레임 정보를 질의하여, 응답받은 프레임과 싱크를 맞추는 방식이었다. 하지만 더 단순한 솔루션을 생각했다. 바로 **시간 기반으로 프레임을 계산하는 것**이다

일전에 프레임 질의 방식에서 [시계는 동기화되어야 함](/blog/project/video-sync/%EA%B0%9C%EC%9A%94#%EC%96%B4%EB%A0%A4%EC%9B%80-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%94%9C%EB%A0%88%EC%9D%B4)을 살펴보았었다. 이후 들었던 생각은 "시계가 동기화 되었다면 굳이 프레임 정보를 질의할 필요 없지 않을까??" 였다. 즉, UNIX 타임처럼 **기준 시각으로부터 얼마나 흘렀는지 ms 단위로 측정하여, 현재 재생해야할 프레임을 계산**하는 프레임 추정 방식을 생각하였다

예시:
- 기준 시간: 당일 00시 00분 00.000초 → 0ms
- 현재 시간: 14시 35분 15.378초 → 52,515,378ms
- 영상 길이: 5분 35.249초 → 335,249ms
- 프레임 레이트: 30fps
- 추정 프레임: **689.318 프레임**(계산 과정 생략)

이 방법을 사용하면 프레임 질의를 하지않고도 스스로 계산하여 프레임 추정이 가능하다. 현재 시간을 제외하고 모든 브라우저는 동일한 수식, 동일한 값을 사용하기 때문에 현재 시간의 오차가 작을수록 추정 프레임 값의 정밀도는 올라간다

---

## 시계 동기화 방식 고민
### Web API, 패키지 탐색
오차 범위 50ms 이하의 브라우저간 시계 동기화를 지원하는 Web API 또는 패키지가 있는지 찾아보았다. 혹은 Public NTP 서버와 UDP 연결을 지원하는 Web API 또는 패키지 또한 찾아보았다. 아쉽게도 **찾지 못하였다**. 직접 구현해야만 한다

### 크리스티안 알고리즘
시간 동기화 알고리즘들 중 **크리스티안 알고리즘([Cristian's algorithm](https://en.wikipedia.org/wiki/Cristian%27s_algorithm))을** 채택하였다

위키 설명에 따르면 크리스티안 알고리즘은 네트워크 지연을 고려하여 시계를 동기화한다. 주로 저지연 인트라넷 환경에서 사용되는 알고리즘이라 한다. RTT 값이 100% 정확할 수 없기에 계산된 값은 확률적이며, RTT 값이 짧고 대칭성이 높을수록 정밀도가 올라간다:

![크리스티안 알고리즘 시퀀스 다이어그램](/markdown/blog/project/video-sync/sequence_diagram_cristian.png)

1. PROCESS가 SERVER에게 요청을 보냄(`t0`)
2. SERVER는 자신의 시간 정보를 담은 응답을 반환한다
3. PROCESS가 응답을 받고(`t1`), 자신의 시간을 조정한다(`TServer + RTT/2`로 설정)

서버 컴퓨터로 구성된 인트라넷 환경을 염두에 두고 고안된 알고리즘이긴 하지만, 각 **서버를 브라우저로 치환하고 WebRTC로 연결성을 확보하면 브라우저간 시계 동기화에도 적용가능하다 생각하여** 채택하였다(수식이 단순한 것도 한 몫 하였다)

### Clinet/Server 토폴로지로 회귀??
이쯤에 와서 일전에 기각했던 Client/Server 토폴로지를 다시금 살펴보았다. 만일 다음과 같이 Main 브라우저를 서버로 바꾼다면 어떨까??

![시퀀스 다이어그램](/markdown/blog/project/video-sync/client_server_topology_proxy.png)

위와 같은 구조를 채택하면 정말 많은 장점들이 생긴다!
1. 구현이 단순해진다. 브라우저는 서로 소통할 필요 없이 중앙 서버와 시간만 맞추면 되기 때문이다
2. 일전에 제기했던 [한계점](/blog/project/video-sync/%EA%B0%9C%EC%9A%94#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%84%9C%EB%B2%84-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80)도 어느정도 극복된다. 브라우저보다 서버의 신뢰도가 더 높기 때문에 서버 다운으로 인한 시스템 fail이 발생할 확률은 높지 않으며, 브라우저와 RESTful하게 소통하면 과부하 문제에서도 비교적 자유로워지기 때문이다
3. 크리스티안 알고리즘에 더 적합한 구조이다:
   * HTTP는 Request Time, Response Time을 요구하는 크리스티안 알고리즘과 잘 맞는 단순한 구조이며, TCP 기반이기 때문에 대칭성이 높다
   * 이에반해 WebRTC는 요청-응답 모델에는 적합하지 않고 복잡한 설정 과정으로인해 불필요한 오버헤드가 예상된다.

이 방식을 적용하지 않을 이유가 없다. 브라우저 만으로 시계 동기화를 해야한다면 모를까, 서버를 하나 중개하는 것만으로 많은 이점이 발생한다. 다만 걱정되는 몇 가지가 있다:
- 크리스티안 알고리즘에선 대칭성이 더 중요하지만, RTT 또한 정밀도에 영향을 미친다. HTTP, WSS의 RTT가 WebRTC에 비해 더 길기 때문에 정밀도에 영향을 미칠 수 있다
- 서버 의존적이게 된다. 서버 관리가 적절히 이뤄지지 않으면 시스템이 fail이 발생한다. 프론트 애플리케이션끼리 자생할 수 있는 구조가 아니기에 시스템 안정성에 있어 불리할 수도 있다

토폴로지를 변경할 것인지 정하기에 앞서 서버를 중개로 한 **크리스티안 알고리즘의 정밀도가 어느 수준인지**를 먼저 파악할 필요가 있을 것 같다(다음 포스팅에서 이러한 데모 구현 내용을 정리할 예정)

---

## 마무리
아키텍처 설계를 곧바로 진행하려 하였는데, 기술 조사를 하다보니 어느새 토폴로지 변경까지 거슬러 올라갔다. 너무 돌고 돌아가는 것은 아닌가 걱정이 된다. 또 한편으론 한참 뒤에 가서 뒤집어 엎는 것보단 지금 시점에서라도 더 나은 솔루션을 찾아내어 다행이라는 생각도 든다. 설계는 참 어렵다. 사실 이게 최선인지도 100% 확신이 서질 않는다