---
title: 비디오 싱크 플레이어 만들기(4)
subtitle: 아키텍처 설계
tags:
  - 설계
  - 비디오 싱크 플레이어
date: 2025-04-27T00:00:00+09:00
---

지난 몇 주간 바빴다. 현재 구직 중이기에 구직 관련된 일들로 바빴다. 특히 과제 전형을 준비하는데 시간을 많이 사용하였다. 누군가의 말 처럼 과제 전형은 리소스를 상당히 많이 소모케 한다. 또 가끔씩은 면접을 보기도 했으며, 부모님을 모시고 3박 4일간 여행도 다녀왔다. 여러모로 프로젝트에 시간을 낼 여유가 많이 없었다. 지연된 감이 없잖아 있지만, 잠깐 여유가 생긴 지금 프로젝트에 다시 집중해보려 한다

시스템에 대한 큰 그림이 명확해졌고, 개별 애플리케이션의 동작 원리 또한 비교적 명확해졌다. 이제 남은일은 설계라 생각한다. 금번 포스트에선 네트워크 토폴로지를 더 명확하게 그린 시스템 아키텍처와 애플리케이션 아키텍처를 설계할 것이다

## 시스템 아키텍처 설계
![시스템 아키텍처](/markdown/blog/project/video-sync/system_architecture.png)
- Frontend Application: 서버와 시계를 동기화하고, 동기화된 시간을 기반으로 프레임을 재생
  - GET `/time` 요청을 통해 서버의 로컬 시간 정보를 얻는다
  - UI 엘리먼트를 통해 유저와의 인터랙션(재생, 영상 데이터 입력 등)을 제공한다
- Backend Application: 프론트의 GET `/time` 요청에 자신의 로컬 타임을 응답

---

## 프론트엔드 애플리케이션 아키텍처 설계
![프론트엔드 애플리케이션 아키텍처](/markdown/blog/project/video-sync/frontend_application_architecture.png)
- 아키텍처 설계에 앞서 가장 먼저 워커 스레드를 사용을 결정하였다. 이유는 다음과 같다:
  1. 만일 메인 스레드에서 블로킹 작업이 빈번하게 일어날 경우 `requestAnimation`의 동작 역시 영향을 받아 프레임 드랍 가능성이 높다. 별도의 스레드에서 영상 재생 작업을 수행하면 프레임 드랍 현상을 줄일 수 있다
  2. 메인 스레드의 역할은 사용자와의 인터랙션, 싱크 맞추기, demuxing 작업 등 전반적인 비즈니스 로직을 담당한다. 이와 달리 워커 스레드는 단순히 영상의 재생만을 담당하도록 하여 아키텍처 복잡도를 낮출 수 있다
- 각 스레드는 서로 어떻게 동작하는지, 어떤 상태인지 알 필요가 없도록 설계하였다. 각자 상태를 관리하되, 전달할 사항이 있으면 `postMessage`와 `onmessage`로 메시지를 주고받는 방식으로 소통한다(서로 엮이는 지점이 있다면 메시지의 타입 정도가 될 것 같다)
- 사실 demuxing이라는 작업이 생소했고, 복잡하게 처리한다는 생각이 들어 `<video>` 엘리먼트 만으로 처리할 수 있는 방법을 고민하였다. `requestVideoFrameCallback` 메소드 활용을 검토해보았지만, 프레임 단위의 '제어' 라는 목적에 맞지는 않아 다시금 WebCodecs API로 돌아왔다
- demuxing 작업이 cpu intensive하다면 이 역시도 별도의 워커 스레드로 빼낼 것이다

---

## 마무리
남은건 구현이다. 레포지토리를 생성하고 하나씩 구현해나가야겠다. 많은 검토를 했기에 논리적 모순은 보이지 않는다. 다만, demuxing이 원하는대로 동작할지 잘 모르겠다